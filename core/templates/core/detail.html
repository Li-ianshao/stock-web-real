{% extends 'core/base_detail.html' %}
{% block content %}

<h2 class="text-3xl font-bold text-indigo-700 mb-4">è‚¡ç¥¨è©³ç´°è³‡è¨Š - {{ symbol }}</h2>

<!-- å±•é–‹ï¼æ”¶åˆå€å¡Š -->
<div class="space-y-6">

    <!-- ğŸ“„ å…¬å¸æè¿°å€å¡Š -->
    <div x-data="{ open: true }" class="border rounded-lg shadow p-4 bg-white">
        <div class="flex justify-between items-center cursor-pointer" @click="open = !open">
            <h3 class="text-lg font-semibold text-gray-800">ğŸ“„ å…¬å¸åŸºæœ¬è³‡æ–™èˆ‡æè¿°</h3>
            <span x-text="open ? 'ï¼' : '+'" class="text-xl text-gray-600"></span>
        </div>
        <div x-show="open" class="mt-4 text-gray-700">
            <div class="bg-white p-4 rounded shadow mb-6">
            <p class="text-sm text-gray-600 mb-2">
                <span class="font-medium">ç”¢æ¥­ï¼š</span>{{ sector }} |
                <span class="font-medium">é¡åˆ¥ï¼š</span>{{ industry }} |
                <span class="font-medium">å“¡å·¥äººæ•¸ï¼š</span>{{ employees }}
            </p>
            <p class="text-sm text-gray-700 whitespace-pre-line leading-relaxed">{{ summary }}</p>
            {% if website %}
                <p class="text-sm text-indigo-600 mt-2">
                <a href="{{ website }}" target="_blank" class="underline">ğŸŒ å®˜æ–¹ç¶²ç«™</a>
                </p>
            {% endif %}
            </div>
        </div>
    </div>

    <!-- ğŸ“ˆ æŠ€è¡“åœ–è¡¨å€å¡Š -->
    <div x-data="{ open: true }" class="border rounded-lg shadow p-4 bg-white">
        <div class="flex justify-between items-center cursor-pointer" @click="open = !open">
            <h3 class="text-lg font-semibold text-gray-800">ğŸ“ˆ æŠ€è¡“åœ–è¡¨åˆ†æ</h3>
            <span x-text="open ? 'ï¼' : '+'" class="text-xl text-gray-600"></span>
        </div>
        <div x-show="open" class="mt-4 space-y-4">

            <!-- Placeholder åœ–è¡¨ -->
            <div class="p-4 bg-gray-100 rounded text-center text-gray-500">
                <div id="chart-candle" class="relative w-full h-[400px] bg-white">
                    <div id="candle-tooltip" class="absolute right-2 bottom-2 bg-gray-100 text-xs text-gray-800 px-2 py-1 rounded shadow hidden"></div>
                </div>
            </div>
            <div class="p-4 bg-gray-100 rounded text-center text-gray-500">
                <div id="chart-volume" class="relative w-full h-[200px] bg-white mt-8">
                    <div id="volume-tooltip" class="absolute right-2 bottom-2 bg-gray-100 text-xs text-gray-800 px-2 py-1 rounded shadow hidden"></div>
                </div>
            </div>
            <div class="p-4 bg-gray-100 rounded text-center text-gray-500">
                <div id="chart-rsi" class="relative w-full h-[200px] bg-white mt-8">
                    <div id="rsi-tooltip" class="absolute right-2 bottom-2 bg-gray-100 text-xs text-gray-800 px-2 py-1 rounded shadow hidden"></div>
                </div>
            </div>
            <div class="p-4 bg-gray-100 rounded text-center text-gray-500">
                <div id="chart-macd" class="relative w-full h-[200px] bg-white mt-8">
                    <div id="macd-tooltip" class="absolute right-2 bottom-2 bg-gray-100 text-xs text-gray-800 px-2 py-1 rounded shadow hidden"></div>
                </div>
            </div>
        </div>
    </div>

</div>

<!-- Alpine.js for toggle -->
<script src="https://unpkg.com/alpinejs" defer></script>
<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
    const priceData = {{ price_data|safe }};
    console.log("è³‡æ–™ç¯„ä¾‹ï¼š", priceData);

    function drawCandleChart(data) {
        const margin = { top: 20, right: 40, bottom: 30, left: 50 },
            width = 900 - margin.left - margin.right,
            height = 400 - margin.top - margin.bottom;

        const svg = d3.select("#chart-candle")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        // è½‰æ›æ—¥æœŸæ ¼å¼
        const parseDate = d3.timeParse("%Y-%m-%d");
        data.forEach(d => {
            d.date = parseDate(d.Date);
            d.Open = +d.Open;
            d.High = +d.High;
            d.Low = +d.Low;
            d.Close = +d.Close;
        });

        // è¨­å®šæ¯”ä¾‹å°º
        const x = d3.scaleBand()
            .domain(data.map(d => d.date))
            .range([0, width])
            .padding(0.3);

        const y = d3.scaleLinear()
            .domain([
                d3.min(data, d => d.Low),
                d3.max(data, d => d.High)
            ])
            .nice()
            .range([height, 0]);

        // Xè»¸ & Yè»¸
        const filteredDates = x.domain().filter((d, i) => i % 5 === 0);  // æ¯éš”ä¸€å€‹é¡¯ç¤ºä¸€æ¬¡

        svg.append("g")
            .attr("transform", `translate(0,${height})`)
            .call(d3.axisBottom(x)
                .tickValues(filteredDates)
                .tickFormat(d3.timeFormat("%m/%d"))
            );

        svg.append("g")
            .call(d3.axisLeft(y));

        // è Ÿç‡­åœ–æœ¬é«”
        svg.selectAll("candlestick")
            .data(data)
            .enter()
            .append("line")
            .attr("x1", d => x(d.date) + x.bandwidth() / 2)
            .attr("x2", d => x(d.date) + x.bandwidth() / 2)
            .attr("y1", d => y(d.High))
            .attr("y2", d => y(d.Low))
            .attr("stroke", "black");

        svg.selectAll("rect")
            .data(data)
            .enter()
            .append("rect")
            .attr("x", d => x(d.date))
            .attr("y", d => y(Math.max(d.Open, d.Close)))
            .attr("height", d => Math.abs(y(d.Open) - y(d.Close)))
            .attr("width", x.bandwidth())
            .attr("fill", d => d.Close > d.Open ? "#00b300" : "#e60000");

        // å¸ƒæ—é€šé“ï¼ˆä¸Šè»Œ & ä¸‹è»Œï¼‰
        const lineUpper = d3.line()
            .defined(d => d.upper_band !== null && !isNaN(d.upper_band))
            .x(d => x(d.date) + x.bandwidth()/2)
            .y(d => y(d.upper_band));

        svg.append("path")
            .datum(data)
            .attr("fill", "none")
            .attr("stroke", "steelblue")
            .attr("stroke-width", 1.5)
            .attr("d", lineUpper);

        const lineLower = d3.line()
            .defined(d => d.lower_band !== null && !isNaN(d.lower_band))
            .x(d => x(d.date) + x.bandwidth()/2)
            .y(d => y(d.lower_band));

        svg.append("path")
            .datum(data)
            .attr("fill", "none")
            .attr("stroke", "orange")
            .attr("stroke-width", 1.5)
            .attr("d", lineLower);

        // åå­—ç·š
        const crosshairV = svg.append("line")
            .attr("stroke", "#999")
            .attr("stroke-width", 1)
            .attr("stroke-dasharray", "3 3")
            .style("display", "none");

        const crosshairH = svg.append("line")
            .attr("stroke", "#999")
            .attr("stroke-width", 1)
            .attr("stroke-dasharray", "3 3")
            .style("display", "none");

        // äº‹ä»¶æ„ŸçŸ¥å€
        svg.append("rect")
            .attr("width", width)
            .attr("height", height)
            .attr("fill", "none")
            .attr("pointer-events", "all")
            .on("mousemove", handleMove)
            .on("touchmove", handleMove)
            .on("click", handleMove);

        function handleMove(event) {
            const [mx, my] = d3.pointer(event);

            const bisectDate = d3.bisector(d => d.date).left;
            const xDate = x.invert ? x.invert(mx) : new Date(x.domain()[Math.floor(mx / x.step())]);
            const idx = bisectDate(data, xDate);
            const d = data[idx];

            if (!d || !d.date) return;

            const cx = x(d.date) + x.bandwidth() / 2;
            const cy = y(d.Close);

            // é¡¯ç¤ºåå­—ç·š
            crosshairV
                .attr("x1", cx)
                .attr("x2", cx)
                .attr("y1", 0)
                .attr("y2", height)
                .style("display", "block");

            crosshairH
                .attr("x1", 0)
                .attr("x2", width)
                .attr("y1", cy)
                .attr("y2", cy)
                .style("display", "block");

            // é¡¯ç¤ºè³‡è¨Šæ¡†
            const box = document.getElementById("candle-tooltip");
            box.innerHTML = `
                <div><b>${d3.timeFormat("%Y-%m-%d")(d.date)}</b></div>
                <div>Open: ${d.Open?.toFixed(2)}</div>
                <div>High: ${d.High?.toFixed(2)}</div>
                <div>Low: ${d.Low?.toFixed(2)}</div>
                <div>Close: ${d.Close?.toFixed(2)}</div>
            `;
            box.classList.remove("hidden");
        }
    }
    function drawVolumeChart(data) {
        const margin = { top: 10, right: 40, bottom: 20, left: 50 },
            width = 900 - margin.left - margin.right,
            height = 200 - margin.top - margin.bottom;

        const svg = d3.select("#chart-volume")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        const parseDate = d3.timeParse("%Y-%m-%d");
        data.forEach(d => {
            d.date = parseDate(d.Date);
            d.Volume = +d.Volume;
        });

        const x = d3.scaleBand()
            .domain(data.map(d => d.date))
            .range([0, width])
            .padding(0.2);

        const y = d3.scaleLinear()
            .domain([0, d3.max(data, d => d.Volume)])
            .nice()
            .range([height, 0]);

        // Xè»¸ & Yè»¸
        const filteredDates = x.domain().filter((d, i) => i % 5 === 0);  // æ¯éš”ä¸€å€‹é¡¯ç¤ºä¸€æ¬¡

        svg.append("g")
            .attr("transform", `translate(0,${height})`)
            .call(d3.axisBottom(x)
                .tickValues(filteredDates)
                .tickFormat(d3.timeFormat("%m/%d"))
            );

        svg.append("g")
            .call(d3.axisLeft(y));

        svg.selectAll("rect")
            .data(data)
            .enter()
            .append("rect")
            .attr("x", d => x(d.date))
            .attr("y", d => y(d.Volume))
            .attr("width", x.bandwidth())
            .attr("height", d => height - y(d.Volume))
            .attr("fill", "#4a90e2");

        // åå­—ç·šå…±ç”¨é‚è¼¯ï¼ˆé‡è¤‡ä½¿ç”¨ï¼‰
        const crosshairV = svg.append("line")
            .attr("stroke", "#999")
            .attr("stroke-width", 1)
            .attr("stroke-dasharray", "3 3")
            .style("display", "none");

        const crosshairH = svg.append("line")
            .attr("stroke", "#999")
            .attr("stroke-width", 1)
            .attr("stroke-dasharray", "3 3")
            .style("display", "none");

        svg.append("rect")
            .attr("width", width)
            .attr("height", height)
            .attr("fill", "none")
            .attr("pointer-events", "all")
            .on("mousemove", handleMove)
            .on("touchmove", handleMove)
            .on("click", handleMove);

        function handleMove(event) {
            const [mx, my] = d3.pointer(event);
            const bisectDate = d3.bisector(d => d.date).left;
            const xDate = x.domain()[Math.floor(mx / x.step())];
            const idx = bisectDate(data, xDate);
            const d = data[idx];

            if (!d || !d.date) return;

            const cx = x(d.date) + x.bandwidth() / 2;
            const cy = y(d.Volume);

            crosshairV
                .attr("x1", cx)
                .attr("x2", cx)
                .attr("y1", 0)
                .attr("y2", height)
                .style("display", "block");

            crosshairH
                .attr("x1", 0)
                .attr("x2", width)
                .attr("y1", cy)
                .attr("y2", cy)
                .style("display", "block");

            const box = document.getElementById("volume-tooltip");
            box.innerHTML = `
                <div><b>${d3.timeFormat("%Y-%m-%d")(d.date)}</b></div>
                <div>Volume: ${d.Volume.toLocaleString()}</div>
            `;
            box.classList.remove("hidden");
        }
    }

    function drawRSIChart(data) {
        const margin = { top: 10, right: 40, bottom: 20, left: 50 },
            width = 900 - margin.left - margin.right,
            height = 200 - margin.top - margin.bottom;

        const svg = d3.select("#chart-rsi")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        const parseDate = d3.timeParse("%Y-%m-%d");
        data.forEach(d => {
            d.date = parseDate(d.Date);
            d.rsi = +d.rsi;
        });

        const x = d3.scaleBand()
            .domain(data.map(d => d.date))
            .range([0, width]);

        const y = d3.scaleLinear()
            .domain([0, 100])
            .range([height, 0]);

        // Xè»¸ & Yè»¸
        const filteredDates = x.domain().filter((d, i) => i % 5 === 0);  // æ¯éš”ä¸€å€‹é¡¯ç¤ºä¸€æ¬¡

        svg.append("g")
            .attr("transform", `translate(0,${height})`)
            .call(d3.axisBottom(x)
                .tickValues(filteredDates)
                .tickFormat(d3.timeFormat("%m/%d"))
            );

        svg.append("g").call(d3.axisLeft(y));

        // RSI æŠ˜ç·š
        const rsiLine = d3.line()
            .defined(d => d.rsi !== null && !isNaN(d.rsi))
            .x(d => x(d.date) + x.bandwidth() / 2)
            .y(d => y(d.rsi));

        svg.append("path")
            .datum(data)
            .attr("fill", "none")
            .attr("stroke", "purple")
            .attr("stroke-width", 2)
            .attr("d", rsiLine);

        // è¶…è²·/è¶…è³£å€
        svg.append("line") // è¶…è²·ç·š
            .attr("x1", 0)
            .attr("x2", width)
            .attr("y1", y(70))
            .attr("y2", y(70))
            .attr("stroke", "red")
            .attr("stroke-dasharray", "4 2");

        svg.append("line") // è¶…è³£ç·š
            .attr("x1", 0)
            .attr("x2", width)
            .attr("y1", y(30))
            .attr("y2", y(30))
            .attr("stroke", "green")
            .attr("stroke-dasharray", "4 2");

        // åå­—ç·š
        const crosshairV = svg.append("line")
            .attr("stroke", "#999")
            .attr("stroke-width", 1)
            .attr("stroke-dasharray", "3 3")
            .style("display", "none");

        const crosshairH = svg.append("line")
            .attr("stroke", "#999")
            .attr("stroke-width", 1)
            .attr("stroke-dasharray", "3 3")
            .style("display", "none");

        // äº’å‹•æ„ŸçŸ¥å€
        svg.append("rect")
            .attr("width", width)
            .attr("height", height)
            .attr("fill", "none")
            .attr("pointer-events", "all")
            .on("mousemove", handleMove)
            .on("touchmove", handleMove)
            .on("click", handleMove);

        function handleMove(event) {
            const [mx, my] = d3.pointer(event);
            const bisectDate = d3.bisector(d => d.date).left;
            const xDate = x.domain()[Math.floor(mx / x.step())];
            const idx = bisectDate(data, xDate);
            const d = data[idx];

            if (!d || d.rsi == null) return;

            const cx = x(d.date) + x.bandwidth() / 2;
            const cy = y(d.rsi);

            crosshairV
                .attr("x1", cx)
                .attr("x2", cx)
                .attr("y1", 0)
                .attr("y2", height)
                .style("display", "block");

            crosshairH
                .attr("x1", 0)
                .attr("x2", width)
                .attr("y1", cy)
                .attr("y2", cy)
                .style("display", "block");

            const box = document.getElementById("rsi-tooltip");
            box.innerHTML = `
                <div><b>${d3.timeFormat("%Y-%m-%d")(d.date)}</b></div>
                <div>RSI: ${d.rsi.toFixed(2)}</div>
            `;
            box.classList.remove("hidden");
        }
    }

    function drawMACDChart(data) {
        const margin = { top: 10, right: 40, bottom: 20, left: 50 },
            width = 900 - margin.left - margin.right,
            height = 200 - margin.top - margin.bottom;

        const svg = d3.select("#chart-macd")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        const parseDate = d3.timeParse("%Y-%m-%d");
        data.forEach(d => {
            d.date = parseDate(d.Date);
            d.hist = +d.hist;
            d.macd = +d.macd;
            d.signal = +d.signal;
        });

        const x = d3.scaleBand()
            .domain(data.map(d => d.date))
            .range([0, width])
            .padding(0.1);

        const y = d3.scaleLinear()
            .domain([
                d3.min(data, d => Math.min(d.hist, d.macd, d.signal, 0)),
                d3.max(data, d => Math.max(d.hist, d.macd, d.signal, 0))
            ])
            .nice()
            .range([height, 0]);

        // Xè»¸ & Yè»¸
        const filteredDates = x.domain().filter((d, i) => i % 5 === 0);  // æ¯éš”ä¸€å€‹é¡¯ç¤ºä¸€æ¬¡

        svg.append("g")
            .attr("transform", `translate(0,${height})`)
            .call(d3.axisBottom(x)
                .tickValues(filteredDates)
                .tickFormat(d3.timeFormat("%m/%d"))
            );

        svg.append("g").call(d3.axisLeft(y));

        // 0 è»¸ç·š
        svg.append("line")
            .attr("x1", 0)
            .attr("x2", width)
            .attr("y1", y(0))
            .attr("y2", y(0))
            .attr("stroke", "#aaa")
            .attr("stroke-dasharray", "3 2");

        // æŸ±ç‹€åœ–ï¼ˆhistï¼‰
        svg.selectAll("rect")
            .data(data)
            .enter()
            .append("rect")
            .attr("x", d => x(d.date))
            .attr("y", d => y(Math.max(0, d.hist)))
            .attr("width", x.bandwidth())
            .attr("height", d => Math.abs(y(d.hist) - y(0)))
            .attr("fill", (d, i) => {
                if (i === 0 || isNaN(data[i - 1].hist)) return "#ccc";  // ç¬¬ä¸€å¤©ç„¡æ³•æ¯”è¼ƒ
                return d.hist > data[i - 1].hist ? "#4CAF50" : "#ff4d4d";  // ç¶ ä¸Šç´…ä¸‹
    });

        // MACD æ›²ç·š
        const macdLine = d3.line()
            .defined(d => d.macd !== null && !isNaN(d.macd))
            .x(d => x(d.date) + x.bandwidth() / 2)
            .y(d => y(d.macd));

        svg.append("path")
            .datum(data)
            .attr("fill", "none")
            .attr("stroke", "purple")
            .attr("stroke-width", 2)
            .attr("d", macdLine);

        // Signal æ›²ç·š
        const signalLine = d3.line()
            .defined(d => d.signal !== null && !isNaN(d.signal))
            .x(d => x(d.date) + x.bandwidth() / 2)
            .y(d => y(d.signal));

        svg.append("path")
            .datum(data)
            .attr("fill", "none")
            .attr("stroke", "orange")
            .attr("stroke-width", 2)
            .attr("d", signalLine);

        // åå­—ç·š
        const crosshairV = svg.append("line")
            .attr("stroke", "#999")
            .attr("stroke-width", 1)
            .attr("stroke-dasharray", "3 3")
            .style("display", "none");

        const crosshairH = svg.append("line")
            .attr("stroke", "#999")
            .attr("stroke-width", 1)
            .attr("stroke-dasharray", "3 3")
            .style("display", "none");

        // æ„ŸçŸ¥å€åŸŸ
        svg.append("rect")
            .attr("width", width)
            .attr("height", height)
            .attr("fill", "none")
            .attr("pointer-events", "all")
            .on("mousemove", handleMove)
            .on("touchmove", handleMove)
            .on("click", handleMove);

        function handleMove(event) {
            const [mx, my] = d3.pointer(event);
            const bisectDate = d3.bisector(d => d.date).left;
            const xDate = x.domain()[Math.floor(mx / x.step())];
            const idx = bisectDate(data, xDate);
            const d = data[idx];
            if (!d || d.macd == null) return;

            const cx = x(d.date) + x.bandwidth() / 2;
            const cy = y(d.hist);

            crosshairV
                .attr("x1", cx)
                .attr("x2", cx)
                .attr("y1", 0)
                .attr("y2", height)
                .style("display", "block");

            crosshairH
                .attr("x1", 0)
                .attr("x2", width)
                .attr("y1", cy)
                .attr("y2", cy)
                .style("display", "block");

            const box = document.getElementById("macd-tooltip");
            box.innerHTML = `
                <div><b>${d3.timeFormat("%Y-%m-%d")(d.date)}</b></div>
                <div>MACD: ${d.macd.toFixed(2)}</div>
                <div>Signal: ${d.signal.toFixed(2)}</div>
                <div>Hist: ${d.hist.toFixed(2)}</div>
            `;
            box.classList.remove("hidden");
        }
    }

    // å‘¼å«ç•«åœ–
    drawMACDChart(priceData);

    drawRSIChart(priceData);

    drawVolumeChart(priceData);

    drawCandleChart(priceData);
</script>

{% endblock %}
    // å‘¼å«ç•«åœ–